import { sanitizePerspective } from "../utils.js";
import { DRAFT_SYNC_TAG_PREFIX, PUBLISHED_SYNC_TAG_PREFIX } from "../constants.js";
import { stegaEncodeSourceMap } from "@sanity/client/stega";
import { preconnect } from "react-dom";
import { cookies, draftMode } from "next/headers";
import { perspectiveCookieName } from "@sanity/preview-url-secret/constants";
import { jsx } from "react/jsx-runtime";
import "server-only";
import { createClient } from "next-sanity";
import SanityLiveClientComponent from "next-sanity/experimental/client-components/live";
import { unstable_cacheTag, updateTag } from "next/cache";
async function resolvePerspectiveFromCookie({ cookies: jar }) {
	return jar.has(perspectiveCookieName) ? sanitizePerspective(jar.get(perspectiveCookieName)?.value, "drafts") : "drafts";
}
async function sanityCachedFetch(config, { query, params = {}, perspective, stega, requestTag, draftToken, customCacheTags = [] }) {
	"use cache";
	const client = createClient({
		...config,
		useCdn: true
	});
	const useCdn = perspective === "published";
	const { result, resultSourceMap, syncTags } = await client.fetch(query, params, {
		filterResponse: false,
		returnQuery: false,
		perspective,
		useCdn,
		resultSourceMap: stega ? "withKeyArraySelector" : void 0,
		cacheMode: useCdn ? "noStale" : void 0,
		tag: requestTag,
		token: perspective === "published" ? config.token : draftToken || config.token
	});
	const tags = [...customCacheTags, ...(syncTags || []).map((tag) => `${perspective === "published" ? PUBLISHED_SYNC_TAG_PREFIX : DRAFT_SYNC_TAG_PREFIX}${tag}`)];
	unstable_cacheTag(...tags);
	return {
		data: result,
		sourceMap: resultSourceMap || null,
		tags
	};
}
function defineLive(config) {
	const { client: _client, serverToken, browserToken } = config;
	if (!_client) throw new Error("`client` is required for `defineLive` to function");
	if (process.env.NODE_ENV !== "production" && !serverToken && serverToken !== false) console.warn("No `serverToken` provided to `defineLive`. This means that only published content will be fetched and respond to live events. You can silence this warning by setting `serverToken: false`.");
	if (process.env.NODE_ENV !== "production" && !browserToken && browserToken !== false) console.warn("No `browserToken` provided to `defineLive`. This means that live previewing drafts will only work when using the Presentation Tool in your Sanity Studio. To support live previewing drafts stand-alone, provide a `browserToken`. It is shared with the browser so it should only have Viewer rights or lower. You can silence this warning by setting `browserToken: false`.");
	const client = _client.withConfig({
		allowReconfigure: false,
		useCdn: false
	});
	const { token: originalToken, stega: stegaConfig } = client.config();
	const studioUrlDefined = typeof client.config().stega.studioUrl !== "undefined";
	const { stega: stegaEnabled = typeof client.config().stega.studioUrl !== "undefined" } = config;
	return {
		sanityFetch: async function sanityFetch({ query, params = {}, stega: _stega, tags: customCacheTags = [], perspective: _perspective, requestTag = "next-loader.fetch" }) {
			const stega = _stega ?? (stegaEnabled && studioUrlDefined && (await draftMode()).isEnabled);
			const perspective = _perspective ?? ((await draftMode()).isEnabled ? "drafts" : "published");
			const { apiHost, apiVersion, useProjectHostname, dataset, projectId, requestTagPrefix } = client.config();
			const { data: _data, sourceMap, tags } = await sanityCachedFetch({
				apiHost,
				apiVersion,
				useProjectHostname,
				dataset,
				projectId,
				requestTagPrefix,
				token: originalToken
			}, {
				query,
				params: await params,
				perspective,
				stega,
				requestTag,
				draftToken: serverToken,
				customCacheTags
			});
			return {
				data: stega && sourceMap ? stegaEncodeSourceMap(_data, sourceMap, {
					...stegaConfig,
					enabled: true
				}) : _data,
				sourceMap,
				tags,
				perspective
			};
		},
		SanityLive: function SanityLive(props) {
			const { refreshOnMount = false, refreshOnFocus = false, refreshOnReconnect = false, requestTag, onError, onGoAway, intervalOnGoAway, revalidateSyncTags = expireTags } = props;
			const { projectId, dataset, apiHost, apiVersion, useProjectHostname, requestTagPrefix } = client.config();
			const { origin } = new URL(client.getUrl("", false));
			preconnect(origin);
			return /* @__PURE__ */ jsx(SanityLiveServerComponent, {
				config: {
					projectId,
					dataset,
					apiHost,
					apiVersion,
					useProjectHostname,
					requestTagPrefix
				},
				requestTag,
				browserToken,
				refreshOnMount,
				refreshOnFocus,
				refreshOnReconnect,
				onError,
				onGoAway,
				intervalOnGoAway,
				revalidateSyncTags,
				resolveDraftModePerspective: props.resolveDraftModePerspective ?? resolveDraftModePerspective
			});
		}
	};
}
const SanityLiveServerComponent = async function SanityLiveServerComponent$1(props) {
	"use cache";
	const { config, requestTag, intervalOnGoAway, onError, onGoAway, refreshOnFocus, refreshOnMount, refreshOnReconnect, revalidateSyncTags, browserToken, resolveDraftModePerspective: resolveDraftModePerspective$1 } = props;
	const { isEnabled: isDraftModeEnabled } = await draftMode();
	return /* @__PURE__ */ jsx(SanityLiveClientComponent, {
		config: {
			...config,
			token: typeof browserToken === "string" && isDraftModeEnabled ? browserToken : void 0
		},
		requestTag,
		draftModeEnabled: isDraftModeEnabled,
		refreshOnMount,
		refreshOnFocus,
		refreshOnReconnect,
		onError,
		onGoAway,
		intervalOnGoAway,
		revalidateSyncTags,
		resolveDraftModePerspective: resolveDraftModePerspective$1
	});
};
async function expireTags(_tags) {
	"use server";
	if (!Array.isArray(_tags)) {
		console.warn("<SanityLive /> `expireTags` called with non-array tags", _tags);
		return;
	}
	const tags = _tags.filter((tag) => typeof tag === "string" && tag.startsWith(PUBLISHED_SYNC_TAG_PREFIX));
	if (!tags.length) {
		console.warn("<SanityLive /> `expireTags` called with no valid tags", _tags);
		return;
	}
	for (const tag of tags) updateTag(tag);
	console.log(`<SanityLive /> updated tags: ${tags.join(", ")}`);
}
async function resolveDraftModePerspective() {
	"use server";
	if ((await draftMode()).isEnabled) return resolvePerspectiveFromCookie({ cookies: await cookies() });
	return "published";
}
export { defineLive, resolvePerspectiveFromCookie };

//# sourceMappingURL=live.js.map